JavaWorkspace_MT/UnitUnderTest/src/main/java/deliverables/UUT_TCPserver.java
=======================================================
lhs: 100644 | 511c07c09f57119c61f799d35f7013f0761389be
rhs: 100644 | 39ceced93f2503421dc8fc89a052664cf52b07ac
---@@ -7,39 +7,137 @@ import tcpServer.TCPserver;
 
 public class UUT_TCPserver{
 	
+	/***********************************************************************************************************
+	 * UUT_TCPserver - Class Attributes
+	 ***********************************************************************************************************/
+    private int port = 0;
+    private TCPserver TCPserver_INSTANCE = null;
+    
+    /***********************************************************************************************************
+	 * Method Name: 
+	 * 		private UUT_TCPserver(int port)
+	 * Description: 
+	 * 		UUT_TCPserver class default constructor
+	 * Affected internal variables: 
+	 * 		TCPserver_INSTANCE
+	 * 		port
+	 * Called external functions:
+	 * 		TCPserver()
+	 * Exceptions thrown:
+	 * 		IOException
+	 ***********************************************************************************************************/
+    UUT_TCPserver(int port) throws IOException {
+    	super();
+    	this.port = port;
+    	this.TCPserver_INSTANCE = new TCPserver();
+    }
+    
     /***********************************************************************************************************
-	 * Method Name: public static void main(String []args)
-	 * Description: Calls constructors of the TCPserver class 
-	 * Affected external variables: TCPserver_instance
-	 * Called external functions: TCPserver.getInstance()
-	 * Exceptions handled: IOException, BindException, SocketException
+	 * Method Name: 
+	 * 		public static void main(String []args)
+	 * Description: 
+	 * 		Creates instance of UUT_TCPserver with TCPserver attribute that is solely responsible for 
+	 * 		handling the communication on the server side
+	 * Affected internal variables:
+	 * 		TCPserver_INSTANCE
+	 * 		port
+	 * Called internal functions: 	
+	 * 		UUT_TCPserver()
+	 * 		runTheServer()
 	 ***********************************************************************************************************/
 	public static void main(String []args){
 		
-		// local variable that determines the port on which the TCP communication is going to take place
 		int temp_port = 9876;
+		UUT_TCPserver uut1_TCPserver = null;
 		
-		// call the default constructor of the TCPserver class
 		try {
-			TCPserver.getInstance(temp_port);
+			uut1_TCPserver = new UUT_TCPserver(temp_port);
 		} catch (IOException IOEx) {
 			System.out.println("Error: Instance for the TCP server at port: "+temp_port+" cannot be created");
 			IOEx.printStackTrace();
 		}
 		
-		// call the overloaded constructor of the TCPserver class that triggers entire communication handling on the server side
+		uut1_TCPserver.setINSTANCE(runTheServer(uut1_TCPserver.getINSTANCE(), uut1_TCPserver.getPort()));
+		
+		// close the server once TCPserver leaves the infinite while loop - it can happen in case of watchdog expiration
+		//uut1_TCPserver.setINSTANCE(closeTheServer(uut1_TCPserver.getINSTANCE(), uut1_TCPserver.getPort()));
+	}
+	
+    /***********************************************************************************************************
+	 * Method Name: 
+	 * 		public static TCPserver runTheServer(TCPserver TCPserver_INSTANCE, int port)
+	 * Description: 
+	 * 		Calls initServer() function for TCPserver attribute 
+	 * Affected internal variables:
+	 * 		TCPserver_INSTANCE
+	 * Called external functions:
+	 * 		TCPserver.initServer()
+	 * Returned value:
+	 * 		TCPserver_INSTANCE
+	 * Exceptions handled:
+	 * 		BindException
+	 * 		SocketException
+	 * 		IOException
+	 ***********************************************************************************************************/
+	public static TCPserver runTheServer(TCPserver TCPserver_INSTANCE, int port){
 		try {	
-			TCPserver.getInstance(temp_port);
-		} catch (BindException BindEx) { // exception is being thrown if program was started more than once
-			System.out.println("Error: The server with port: "+temp_port+" already exists and cannot be bound to the requested port ");
+			TCPserver_INSTANCE = TCPserver_INSTANCE.initServer(port);
+		} catch (BindException BindEx) { // exception happens if program was started more than once
+			System.out.println("Error: The server with port: "+port+" already exists and cannot be bound to the requested port ");
 			BindEx.printStackTrace();
-		} catch (SocketException socketEx) { // exception is being thrown if there was an attempt to run more than one server instance regardless of the port number
-	    	System.out.println("Error: The server with port="+temp_port+" returns the SocketException if there is an issue in the underlying protocol, such as a TCP error");
+		} catch (SocketException socketEx) { // exception happens if there was an attempt to run more than server regardless of the port number
+	    	System.out.println("Error: The server with port="+port+" returns the SocketException if there is an issue in the underlying protocol, such as a TCP error");
 	    	socketEx.printStackTrace();
 	    } catch (IOException IOEx) {
-	    	System.out.println("Error: The server with port="+temp_port+" returns the IOException if the bind operation fails, or if the socket is already bound.");
+	    	System.out.println("Error: The server with port="+port+" returns the IOException if the bind operation fails, or if the socket is already bound.");
 	    	IOEx.printStackTrace();
 	    } 
+		return TCPserver_INSTANCE;
 	}
+	
+   /***********************************************************************************************************
+	 * Method Name: 
+	 * 		public static TCPserver closeTheServer(TCPserver TCPserver_INSTANCE, int port)
+	 * Description: 
+	 * 		Calls closeServer() function for TCPserver attribute 
+	 * Affected internal variables:
+	 * 		TCPserver_INSTANCE
+	 * Called external functions:
+	 * 		TCPserver.closeServer()
+	 * Returned value:
+	 * 		TCPserver_INSTANCE
+	 * Exceptions handled:
+	 * 		IllegalArgumentException
+	 * 		SocketException
+	 * 		IOException
+	 ***********************************************************************************************************/
+	public static TCPserver closeTheServer(TCPserver TCPserver_INSTANCE, int port){	
+		try {
+			TCPserver_INSTANCE.closeServer(TCPserver_INSTANCE, port);
+		}  catch (IllegalArgumentException illPTREx ){
+			System.out.println("Error: The server with port= "+port+" returns the IllegalArgumentException if there was an attempt to close a server socket that has not been initialized");
+			illPTREx.printStackTrace();
+		}  catch (SocketException socketEx ){
+			System.out.println("Error: The server with port= "+port+" returns the SocketException if there was an attempt to close a socket that runs a thread currently blocked in accept()");
+			socketEx.printStackTrace();
+		} catch (IOException IOEx ){
+			System.out.println("Error: The server with port="+port+" cannot be closed");
+			IOEx.printStackTrace();
+		} 
+		return TCPserver_INSTANCE;
+	}
+	
+	public void setINSTANCE(TCPserver TCPserver_INSTANCE) {
+		this.TCPserver_INSTANCE = TCPserver_INSTANCE;
+	}
+
+	public TCPserver getINSTANCE() {
+		return this.TCPserver_INSTANCE;
+	}
+
+	public int getPort() {
+		return this.port;
+	}
+
 }
     

---JavaWorkspace_MT/UnitUnderTest/src/main/java/tcpClient/ClientManager.java
=======================================================
lhs: 100644 | 4e1747467323f2e30511c496c61e8017bc18ef20
rhs: 100644 | 1548b98bad1f22bd8ead4a5c5b951f33daf53f8e
---@@ -211,7 +211,7 @@ public class ClientManager implements TCPclient_interface{
 						}
 						else {
 							// send ACK message to confirm that ClientMessage_MeasurementData has been sent, but do not disable the socket on the server side - the sensor waits for ServerMessage_Request_MeasurementHistory
-							System.out.println("[ClientManager " +sensor.getSensorID()+"] ClientMessage_ACK has been sent to confirm that ClientMessage_MeasurementData has been sent - wait for ServerMessage_Request_MeasurementHistory");
+							System.out.println("[ClientManager " +sensor.getSensorID()+"] ClientMessage_ACK has been sned to confirm that ClientMessage_MeasurementData has been sent - wait for ServerMessage_Request_MeasurementHistory");
 							sendMessage(new ClientMessage_ACK(sensor_ID));
 						}
 

---JavaWorkspace_MT/UnitUnderTest/src/main/java/tcpServer/ComputeEngine_Runnable.java
=======================================================
lhs: 100644 | cd9f1ad7cee45ecb495846da8127fc4a8ebb9a06
rhs: 100644 | e8f401d25d715d894c87ad5ed2753ebe91dfedbb
---@@ -66,7 +66,7 @@ public class ComputeEngine_Runnable extends TCPserver implements Runnable {
     	try {
     		while(true) {
     			
-    			setDelay(200 * getLocal_watchdog_scale_factor());
+    			setDelay(100 * getLocal_watchdog_scale_factor());
     			if(isComputeEngine_Runnable_running()) {
     				
 					if( (receivedMessage = (Message_Interface) inputStream.readObject()) != null) {
@@ -91,7 +91,6 @@ public class ComputeEngine_Runnable extends TCPserver implements Runnable {
 		    					// conversion from [ms] (getDelay) to [s] (getLocal_1h_watchdog) is required, hence multiplication by 0.001
 			    				setLocal_1h_watchdog(getLocal_1h_watchdog() - ((double)((0.001 * getDelay()))));
 			    				
-			    				setDelay(200 * getLocal_watchdog_scale_factor());
 			    				System.out.println("[Compute engine Runnable " +sensor.getSensorID()+"] 1h_Watchdog updated including the delay for ServerMessage_Request_MeasurementData: \t" + getLocal_1h_watchdog());
 		    				}
 		    				else if(getLocal_24h_watchdog() < (200 * getLocal_watchdog_scale_factor()) ) {
@@ -102,7 +101,7 @@ public class ComputeEngine_Runnable extends TCPserver implements Runnable {
 			    				setLocal_24h_watchdog(getLocal_24h_watchdog() - ((double)((0.001 * getDelay()))));
 			    				
 			    				// delay is set to a minimal value to prevent 1h Watchdog from expiration
-			    				setDelay(200 * getLocal_watchdog_scale_factor());
+			    				setDelay(100 * getLocal_watchdog_scale_factor());
 			    				System.out.println("[Compute engine Runnable " +sensor.getSensorID()+"] 24h_Watchdog updated including the delay for ServerMessage_Request_MeasurementHistory: \t" + getLocal_24h_watchdog());
 		    				}
 		    				else {
@@ -230,8 +229,8 @@ public class ComputeEngine_Runnable extends TCPserver implements Runnable {
     						// serialize measurement data instance and save it to file
         					getProcessing_engine().saveMeasurementHistoryInfo(sensor, mes_hist);
 	        					
-        					// reset sensor to create new MeasurementData array, set NumberOfMeasurements to 0 and set SensorState to PRE_OPERATIONAL
         					sensor.resetSensor();
+        					Server_Sensors_LIST = getProcessing_engine().updateServerSensorList(sensor);
 
 	    					// feed Local 24hWatchdog
         					setLocal_24h_watchdog(Global_24h_Watchdog.getInstance().getExpiration() * getLocal_watchdog_scale_factor());
@@ -248,8 +247,6 @@ public class ComputeEngine_Runnable extends TCPserver implements Runnable {
 	    					sendMessage(new ServerMessage_SensorInfoUpdate(sensor.getSensorID(), sensor.getCoordinates(), sensor.getSoftwareImageID(), sensor.getSensorState(),
 	    																   getLocal_1h_watchdog(), getLocal_24h_watchdog(), 
 									   									   getLocal_watchdog_scale_factor(), getMeasurements_limit()));
-	    					
-	    					Server_Sensors_LIST = getProcessing_engine().updateServerSensorList(sensor);
 	    				}
 		    		}
 					processingDelay(getDelay());
@@ -351,7 +348,6 @@ public class ComputeEngine_Runnable extends TCPserver implements Runnable {
 				set_24hWatchog_Allfalse();
 			}
         	try {
-        		processingDelay(100);
         		closeOutStream();
 				closeInStream();
 			} catch (IOException IOex) {

---JavaWorkspace_MT/UnitUnderTest/src/main/java/tcpServer/TCPserver.java
=======================================================
lhs: 100644 | 7663275df5ba64a9fe017e50197f7b322061d098
rhs: 100644 | f4907758ba9afd891377b52de412dda91c460285
---@@ -22,20 +22,17 @@ public class TCPserver {
     /***********************************************************************************************************
 	 * TCPserver - Class Attributes
 	 ***********************************************************************************************************/
-	// instance of TCPserver that should be referred in case of any modification to the TCPserver class attributes or any attempt to read the TCPserver class attribute
-	private static TCPserver TCPserver_instance; 
-	
     //declare a TCP socket object and initialize it to null
-	private static ServerSocket serverSocket = null;
+	private ServerSocket serverSocket = null;
 	
 	//  determine the maximum number of threads running at the same time
 	private final ThreadPoolExecutor clientProcessingPool = new ThreadPoolExecutor(8, 8, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
 
 	// instance of the Thread class that starts the server thread and enables the server to handle multiple connections with TCP clients in different threads
-	private static Thread serverThread = null;
+	private Thread serverThread = null;
 	
 	// flag that indicates if TCPserver is running
-	private static boolean serverRunning = false;
+	private boolean serverRunning = false;
 	
 	// instance of the ComputeEngine_Processing class that triggers processing of the previously serialized files saved in the defined directory
 	private static ComputeEngine_Processing processing_engine; 
@@ -48,7 +45,7 @@ public class TCPserver {
 	protected static ArrayList<MeasurementData> MeasurementData_LIST= new ArrayList<>();
 	
 	// directory that determines where the serialized files for a particular sensor will be saved
-	protected static final String Sensors_PATH = "files\\sensors";
+	protected static String Sensors_PATH = "files\\sensors";
 
 	// data to be loaded to sensor instances after initializing them
 	protected float[][] sensor_coordinates_array = { {1.0f, 1.0f} , {2.0f, 1.0f}, {1.5f, 2.0f}};// {2.5f, 0.5f}, {3.0f, 3.5f}};//  {1.0f, 3.5f}, {2.5f, 0.5f}, {0.5f, 2.5f}};
@@ -90,7 +87,7 @@ public class TCPserver {
 	 * Affected external variables: Global_1h_Watchdog, Global_24h_Watchdog
 	 * Exceptions thrown:			IOException
 	 ***********************************************************************************************************/
-	public TCPserver() throws IOException{
+  public TCPserver() throws IOException{
 		// if there will be any class attribute initialized to default value in the declaration section, here its value will be reinitialized
 		super();
 		
@@ -110,7 +107,7 @@ public class TCPserver {
 	 * Exceptions thrown: 			IOException
 	 * Exceptions handled: 			ClassNotFoundException, FileNotFoundException, NotSerializableException
 	 ***********************************************************************************************************/
-	TCPserver(int port) throws IOException{
+	private TCPserver(int port) throws IOException{
 		
 		// communication stuff
 		serverSocket = new ServerSocket();
@@ -126,6 +123,8 @@ public class TCPserver {
 	    Global_24h_Watchdog.getInstance().setEnabled(get_ServerRunning());
 	    
 	    // data processing stuff 
+	    // create instances of sensors on the server side and add them to the Server_Sensors_LIST
+	    
 	    try {
 	    	processing_engine = new ComputeEngine_Processing();
 	    } catch (ClassNotFoundException CNFex) {
@@ -133,10 +132,8 @@ public class TCPserver {
         	System.out.println(CNFex.getMessage());
         }
 	    
-	    // delete all files on the server side
 	    processing_engine.deleteAllFilesFromDirectiory(Sensors_PATH);
 	    
-	    // create instances of sensors on the server side and add them to the Server_Sensors_LIST
     	for (int i = 1; i <= sensor_coordinates_array.length; i++) {
     		try {
 	    		SensorImpl temp_sensor = new SensorImpl(i, new Point2D.Float(sensor_coordinates_array[i-1][0], sensor_coordinates_array[i-1][1]), "Release 1", getMeasurements_limit());
@@ -163,47 +159,36 @@ public class TCPserver {
 	};
 
     /***********************************************************************************************************
-	 * Method Name: 				public static synchronized TCPserver getInstance(int port)
-	 * Description: 				if this function is called for the first time, the default constructor of the TCPserver class is being called,
-	 								if this function is called for the second time, the overloaded constructor of the TCPserver class is being called,
-	 								otherwise, the already initialized instance of the TCPserver class is being returned
-	 * Affected internal variables: TCPserver_instance								
-	 * Returned value				TCPserver_instance
+	 * Method Name: 				public TCPserver initServer(int port)
+	 * Description: 				calls overloaded constructor of TCPserver that triggers entire communication handling on the server side
+	 * Returned value				TCPserver
 	 * Called internal functions: 	TCPserver()
 	 * Exceptions thrown: 			IOException
 	 ***********************************************************************************************************/
-    public static synchronized TCPserver getInstance(int port) throws IOException { 
-        if (TCPserver_instance == null) { 
-        	TCPserver_instance = new TCPserver(); 
-        } 
-        else if (!get_ServerRunning()) { 
-        	TCPserver_instance = new TCPserver(port); 
-        } 
-        return TCPserver_instance; 
-    } 
+	public TCPserver initServer(int port) throws IOException {
+		return (new TCPserver(port));
+	}
 	
     /***********************************************************************************************************
 	 * Method Name: 				public void closeServer(TCPserver INSTANCE, int port
 	 * Description: 				Closes server socket for TCPserver and kicks 1h_Watchdog since server socket has been closed intentionally
-	 * Affected internal variables: serverSocket, serverRunning, serverThread
-	 * Affected external variables: Global_1h_Watchdog.millisecondsLeftUntilExpiration
+	 * Affected internal variables: serverSocket, serverRunning
+	 * Affected external variables: Global_1h_Watchdog
 	 * Called external functions: 	Global_1h_Watchdog.setTimeLeftBeforeExpiration()
 	 * Exceptions thrown: 			IOException, IllegalArgumentException
 	 ***********************************************************************************************************/
 	public void closeServer(TCPserver INSTANCE, int port) throws IOException{
 	
-		if (get_ServerRunning()){
+		if (INSTANCE.getServerSocket()!= null){
 			
-			TCPserver.getServerSocket().close();
-			getServerThread().interrupt();
+			INSTANCE.getServerSocket().close();
+			System.out.println("[TCPserver] Socket for the server with port: "+port+" closed successfully");
 			
 			// set to 1hWatchdog 30 [s] to activate the client socket when Watchdog time before expiration reaches its specified level (client-socket opening level)
-			Global_1h_Watchdog.getInstance().setTimeLeftBeforeExpiration(Global_1h_Watchdog.getInstance().getExpiration() * getWatchdogs_scale_factor());
+			Global_1h_Watchdog.getInstance().setTimeLeftBeforeExpiration(3600 * getWatchdogs_scale_factor());
 			
 			// reinitialize set_ServerRunning to false
 			set_ServerRunning(false);
-			
-			System.out.println("[TCPserver] Socket for the server with port: "+port+" closed successfully");
 		} 
 		else {
 			throw new IllegalArgumentException();
@@ -218,7 +203,7 @@ public class TCPserver {
 	 * Exceptions handled: 			IllegalThreadStateException, IOException
 	 ***********************************************************************************************************/
 	public void startServer(final ServerSocket serverSocket){
-		TCPserver.serverThread = new Thread(new Runnable() {
+		this.serverThread = new Thread(new Runnable() {
 	        public void run() {
 	            try {
 	            	Socket clientSocket = null;
@@ -333,24 +318,24 @@ public class TCPserver {
 	    return returned_flag;
 	}
 	
-	public synchronized static ServerSocket getServerSocket() {
-		return serverSocket;
+	public synchronized ServerSocket getServerSocket() {
+		return this.serverSocket;
 	}
 	
-	public synchronized static Thread getServerThread() {
-		return serverThread;
+	public synchronized Thread getServerThread() {
+		return this.serverThread;
 	}
 	
 	synchronized ThreadPoolExecutor getThreadPoolExecutor() {
 		return this.clientProcessingPool;
 	}	
 	
-	public synchronized static boolean get_ServerRunning() {
-		return serverRunning;
+	public synchronized boolean get_ServerRunning() {
+		return this.serverRunning;
 	}
 	
-	public synchronized static void set_ServerRunning(boolean isServerRunning) {
-	    serverRunning = isServerRunning;
+	public synchronized void set_ServerRunning(boolean isServerRunning) {
+	    this.serverRunning = isServerRunning;
 	}
 	
 	public static ComputeEngine_Processing getProcessing_engine() {
@@ -369,11 +354,13 @@ public class TCPserver {
 	
 	/******************************************************************************************************************************************
 	 * Auxiliary piece of code
-	 * Testing Interfaces Method Names: 1) static double getWatchdogs_scale_factor()
-	 * 									2) static void setWatchdogs_scale_factor(double watchdogs_scale_factor)
-	 *									3) boolean get_isComputeEngineRunning()
-	 *									4) set_ComputeEngineRunning(boolean set_ComputeEngineRunning)
+	 * Testing Interfaces Method Names: 
+	 * 								1) static double getWatchdogs_scale_factor()
+	 * 								2) static void setWatchdogs_scale_factor(double watchdogs_scale_factor)
+	 *								3) boolean get_isComputeEngineRunning()
+	 *								4) set_ComputeEngineRunning(boolean set_ComputeEngineRunning)
 	 *****************************************************************************************************************************************/
+	
 	public synchronized static double getWatchdogs_scale_factor() {
 		return watchdogs_scale_factor;
 	}

---JavaWorkspace_MT/UnitUnderTest/src/main/java/watchdog/Global_1h_Watchdog.java
=======================================================
lhs: 100644 | cffb3fef63ca84cf0e0d2d3cc7335be2c24614c1
rhs: 100644 | 1fef105c17d5e25e3025ede3ef8e3970ea5be2d1
---@@ -45,7 +45,7 @@ public class Global_1h_Watchdog implements Runnable {
     // _1h_Watchdog expiration time decrementation timeIntervals in milliseconds (its value is decremented every second)
     private int timeIntervals = 1000; 
 	private boolean isPaused = false; 
-	private static double server_watchgod_scale_factor = 1.0;
+	private double server_watchgod_scale_factor = 1.0;
 
 	/*
      * The _1h_Watchdog is born. 
@@ -102,7 +102,7 @@ public class Global_1h_Watchdog implements Runnable {
      * @return The number of seconds left to _1h_Watchdog expiration. 
      */ 
     public double getTimeLeftBeforeExpiration() { 
-        return millisecondsLeftUntilExpiration * 0.001;  
+        return millisecondsLeftUntilExpiration / 1000.0; 
     } 
     
     /*
@@ -110,7 +110,7 @@ public class Global_1h_Watchdog implements Runnable {
      * It should be called to update _1h_Watchdog on the client side respectively to the _1h_Watchdog
      */ 
     public void setTimeLeftBeforeExpiration(double _1h_WatchdogExpiration) { 
-    	 millisecondsLeftUntilExpiration = (long) (_1h_WatchdogExpiration * 1000); 
+    	 millisecondsLeftUntilExpiration = (long) (_1h_WatchdogExpiration*1000); 
     } 
     
     /*
@@ -119,7 +119,7 @@ public class Global_1h_Watchdog implements Runnable {
      * @return The number of seconds since last meal. 
      */ 
     public double getTimeFromLastFeed() { 
-        return (_1h_WatchdogExpiration - (millisecondsLeftUntilExpiration * 0.001)); 
+        return (_1h_WatchdogExpiration - (millisecondsLeftUntilExpiration / 1000.0)); 
     } 
  
     /*
@@ -127,7 +127,7 @@ public class Global_1h_Watchdog implements Runnable {
      * 
      * @return The number of seconds before starvation following a meal (_1h_Watchdog starves if it doesn't eat this often). 
      */ 
-    public int getExpiration() { 
+    public double getExpiration() { 
         return _1h_WatchdogExpiration; 
     } 
 
@@ -211,12 +211,12 @@ public class Global_1h_Watchdog implements Runnable {
 		this.timeIntervals = timeIntervals;
 	}
 	 
-    public static double getServer_watchgod_scale_factor() {
+    public double getServer_watchgod_scale_factor() {
 		return server_watchgod_scale_factor;
 	}
 
-	public static void setServer_watchgod_scale_factor(double global_watchgod_scale_factor) {
-		server_watchgod_scale_factor = global_watchgod_scale_factor;
+	public void setServer_watchgod_scale_factor(double global_watchgod_scale_factor) {
+		this.server_watchgod_scale_factor = global_watchgod_scale_factor;
 	}
 
 

---JavaWorkspace_MT/UnitUnderTest/src/main/java/watchdog/Global_24h_Watchdog.java
=======================================================
lhs: 100644 | fc78284aee5828c0bb945b7e040008f0de8ff63d
rhs: 100644 | 72142a880cd5c376ded094bdde93c59f02085026
---@@ -45,7 +45,7 @@ public class Global_24h_Watchdog implements Runnable {
     // _24h_Watchdog expiration time decrementation timeIntervals in milliseconds (its value is decremented every minute)
     private int timeIntervals = 1000;
     private boolean isPaused = false; 
-	private static double server_watchgod_scale_factor = 1.0;
+	private double server_watchgod_scale_factor = 1.0;
 	private int server_measurements_limit; 
 	
     /*
@@ -104,7 +104,7 @@ public class Global_24h_Watchdog implements Runnable {
      * @return The number of seconds left to ServerWatchgod expiration. 
      */ 
     public double getTimeLeftBeforeExpiration() { 
-        return millisecondsLeftUntilExpiration * 0.001; 
+        return millisecondsLeftUntilExpiration / 1000.0; 
     } 
     
     /*
@@ -112,7 +112,7 @@ public class Global_24h_Watchdog implements Runnable {
      * It should be called to update _24h_Watchdog on the client side respectively to the server_24h_Watchdog
      */ 
     public void setTimeLeftBeforeExpiration(double _24h_WatchdogExpiration) { 
-    	 millisecondsLeftUntilExpiration = (long) (_24h_WatchdogExpiration * 1000); 
+    	 millisecondsLeftUntilExpiration = (long) (_24h_WatchdogExpiration*1000); 
     } 
     
     
@@ -122,7 +122,7 @@ public class Global_24h_Watchdog implements Runnable {
      * @return The number of seconds since last meal. 
      */ 
     public double getTimeFromLastFeed() { 
-        return (_24h_WatchdogExpiration - (millisecondsLeftUntilExpiration * 0.001)); 
+        return (_24h_WatchdogExpiration - (millisecondsLeftUntilExpiration / 1000.0)); 
     } 
  
     /*
@@ -214,12 +214,12 @@ public class Global_24h_Watchdog implements Runnable {
 		this.timeIntervals = timeIntervals;
 	}
 	 
-    public static double getServer_watchgod_scale_factor() {
+    public double getServer_watchgod_scale_factor() {
 		return server_watchgod_scale_factor;
 	}
 
-	public static void setServer_watchgod_scale_factor(double global_watchgod_scale_factor) {
-		server_watchgod_scale_factor = global_watchgod_scale_factor;
+	public void setServer_watchgod_scale_factor(double global_watchgod_scale_factor) {
+		this.server_watchgod_scale_factor = global_watchgod_scale_factor;
 	}
 	
     public int getServer_measurements_limit() {

---JavaWorkspace_MT/UnitUnderTest/src/main/java/watchdog/Local_1h_Watchdog.java
=======================================================
lhs: 100644 | 98ba73aa023cd50137d4b743bfa1226a146f198b
rhs: 100644 | 51be3249bef16457ea2d0e443474bebf54018974
---@@ -102,7 +102,7 @@ public class Local_1h_Watchdog implements Runnable {
      * @return The number of seconds left to _1h_Watchdog expiration. 
      */ 
     public double getTimeLeftBeforeExpiration() { 
-        return millisecondsLeftUntilExpiration * 0.001; 
+        return millisecondsLeftUntilExpiration / 1000.0; 
     } 
     
     /*
@@ -119,7 +119,7 @@ public class Local_1h_Watchdog implements Runnable {
      * @return The number of seconds since last meal. 
      */ 
     public double getTimeFromLastFeed() { 
-        return (_1h_WatchdogExpiration - (millisecondsLeftUntilExpiration * 0.001)); 
+        return (_1h_WatchdogExpiration - (millisecondsLeftUntilExpiration / 1000.0)); 
     } 
  
     /*

---JavaWorkspace_MT/UnitUnderTest/src/test/java/deliverables/CloseTCPserverTest.java
=======================================================
lhs: 100644 | 691b4a321a22d1f4418900f02efd24cc9e62321a
rhs: None
file deleted in rhs
---@@ -1,89 +0,0 @@
-package deliverables;
-
-import static org.junit.Assert.*;
-
-import java.io.IOException;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import tcpServer.TCPserver;
-import watchdog.Global_1h_Watchdog;
-
-public class CloseTCPserverTest {
-
-	/***********************************************************************************************************
-	 * CloseTCPserverTest - Class Attributes
-	 ***********************************************************************************************************/
-	int port_1 = 9876;
-	TCPserver temp_TCPserver = null;
-
-	String[] testPurpose = { "Verify that that once the previously created TCPserver instance is being closed, this instance is being overwritten with up-to-date attributes that indicate TCP communication is not active",
-							 "Verify that that once the previously created TCPserver instance is being closed intentionally, 1h_Watchdog TimeLeftBeforeExpiration is being set to its initial limit (_1h_WatchdogExpiration)"};
-	static int testID = 1;
-
-	public static void incrementTestID() {
-		CloseTCPserverTest.testID += 1;
-	}
-	
-	@Before
-	public void before() throws IOException {
-		
-		temp_TCPserver = TCPserver.getInstance(port_1);
-		
-		System.out.println("\t\tTest Run "+StartTCPserverTest.testID+" Purpose:");
-		System.out.println(testPurpose[(StartTCPserverTest.testID-1)]);
-		System.out.println("\t\tTest Run "+StartTCPserverTest.testID+" Logic:");
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: test_run_1
-	 * Description: Verify that that once the previously created TCPserver instance is being closed, 
-	 				this instance is being overwritten with up-to-date attributes that indicate TCP communication is not active
-	 * Affected external variables: TCPserver_instance, TCPserver.serverSocket, TCPserver.serverThread, TCPserver.serverRunning
-	 * Exceptions thrown: IOException
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_1() throws IOException {
-		
-		temp_TCPserver = TCPserver.getInstance(port_1);
-		
-		TCPserver.getInstance(port_1).closeServer(TCPserver.getInstance(port_1), port_1);
-		
-		assertTrue(TCPserver.getServerThread().isInterrupted());
-		assertTrue(TCPserver.getServerSocket().isClosed());
-		assertFalse(TCPserver.get_ServerRunning());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: test_run_2
-	 * Description: Verify that that once the previously created TCPserver instance is being closed intentionally, 
-	 				1h_Watchdog TimeLeftBeforeExpiration is being set to its initial limit (_1h_WatchdogExpiration)
-	 * Affected external variables: Global_1h_Watchdog.millisecondsLeftUntilExpiration
-	 * Exceptions thrown: IOException
-	 ***********************************************************************************************************/
-
-	@Test
-	public void test_run_2() throws IOException {
-		
-		temp_TCPserver = TCPserver.getInstance(port_1);
-		double prev = Global_1h_Watchdog.getInstance().getTimeLeftBeforeExpiration();
-		double temp_1h_WatchdogExpiration =  Global_1h_Watchdog.getInstance().getExpiration() * TCPserver.getWatchdogs_scale_factor() ;
-		
-		TCPserver.getInstance(port_1).closeServer(TCPserver.getInstance(port_1), port_1);
-		double curr_1 = Global_1h_Watchdog.getInstance().getTimeLeftBeforeExpiration(); 
-		
-		assertEquals( temp_1h_WatchdogExpiration,	 curr_1, 0.001);
-		assertTrue("Current 1h_Watchdog TimeLeftBeforeExpiration (" + curr_1 + ") should be greater than previous (" + prev + ")", curr_1 > prev);
-	}
-
-	@After
-    public void teardown() throws IOException, InterruptedException{
-	  
-	   System.out.println("\t\tTest Run "+CloseTCPserverTest.testID+" teardown section:");
-	   	   
-	   // Time offset between consecutive test runs execution
-	   Thread.sleep(1000);
-
-	   incrementTestID();
-    }
-}

---JavaWorkspace_MT/UnitUnderTest/src/test/java/deliverables/CloseTheServerUUT_TCPserverTest.java
=======================================================
lhs: None
rhs: 100644 | 934f0546ea964cf534747713b0c32b51021697e0
file added in rhs
---@@ -0,0 +1,80 @@
+package deliverables;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import tcpServer.TCPserver;
+
+public class CloseTheServerUUT_TCPserverTest {
+
+	int port_1 = 9876;
+	UUT_TCPserver uut_TCPserver_1 = null;
+
+	
+	String[] testPurpose = { 	"Verify that the CloseTheServer function returns an updated instance of the server (in accordance with closeServer() method from the TCPserver class) that overwrites the previously created running instance of the TCP server",
+								"Verify that the instance of TCP server class (one of the attributes of the UUT_TCPserver class that is used for calling the closeTheServer function) is being updated with up-to-date connection data each time the setINSTANCE function is being called for this UUT_TCPserver class object"};
+						
+			
+	static int testID = 1;
+
+	public static void incrementTestID() {
+		CloseTheServerUUT_TCPserverTest.testID += 1;
+	}
+	
+	@Before
+	public void before() throws IOException {
+		uut_TCPserver_1 = new UUT_TCPserver(port_1);
+		
+		if(CloseTheServerUUT_TCPserverTest.testID == 2) {
+			uut_TCPserver_1.setINSTANCE(UUT_TCPserver.runTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort()));
+		}
+		
+		System.out.println("\t\tTest Run "+CloseTheServerUUT_TCPserverTest.testID+" Purpose:");
+		System.out.println(testPurpose[(CloseTheServerUUT_TCPserverTest.testID-1)]);
+		System.out.println("\t\tTest Run "+CloseTheServerUUT_TCPserverTest.testID+" Logic:");
+	}
+	
+	@Test
+	public void test_run_1() throws IOException {
+		
+		TCPserver tcp_server_temp = UUT_TCPserver.runTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort());
+				
+		// close the server instance to prevent the Bind Exception from being thrown due to an attempt to bind a server socket twice to the same port
+		tcp_server_temp.closeServer(tcp_server_temp, port_1);
+		
+		assertNotEquals(null,		tcp_server_temp);
+		assertNotEquals(null,		tcp_server_temp.getServerThread());
+		assertTrue(tcp_server_temp.getServerSocket().isClosed());
+		assertFalse(tcp_server_temp.get_ServerRunning());
+	}
+	
+	@Test
+	public void test_run_2() throws IOException {
+		
+		uut_TCPserver_1.setINSTANCE(UUT_TCPserver.closeTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort()));
+		
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE());
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE().getServerThread());
+		assertTrue(uut_TCPserver_1.getINSTANCE().getServerSocket().isClosed());
+		assertFalse(uut_TCPserver_1.getINSTANCE().get_ServerRunning());
+	}
+	
+	
+   @After
+    public void teardown() throws IOException, InterruptedException{
+	  
+	   System.out.println("\t\tTest Run "+CloseTheServerUUT_TCPserverTest.testID+" teardown section:");
+	   	   
+	   // Time offset between consecutive test runs execution
+	   Thread.sleep(1000);
+
+	   incrementTestID();
+    }
+	   
+}
+

---JavaWorkspace_MT/UnitUnderTest/src/test/java/deliverables/RunTheServerUUT_TCPserverTest.java
=======================================================
lhs: None
rhs: 100644 | 3718eefc3f8ccb51ce56f42d6180f353ffce146e
file added in rhs
---@@ -0,0 +1,160 @@
+package deliverables;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.net.ServerSocket;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import tcpServer.TCPserver;
+
+public class RunTheServerUUT_TCPserverTest {
+
+	/***********************************************************************************************************
+	 * RunTheServerUUT_TCPserverTest - Class Attributes
+	 ***********************************************************************************************************/
+	int port_1 = 9876;
+	UUT_TCPserver uut_TCPserver_1 = null;
+
+	
+	String[] testPurpose = { 	"Verify that once the UUT_TCPserver class constructor is called, an empty instance of the TCP server class is created",
+								"Verify that the RunTheServer function returns an updated and running instance of the server (in accordance with initServer() method from the TCPserver class) that overwrites the previously created empty instance of the TCP server",
+								"Verify that the instance of TCP server class (one of the attributes of the UUT_TCPserver class that is used for calling the closeTheServer function) is being updated with up-to-date connection data each time the setINSTANCE function is being called for this UUT_TCPserver class object"};
+						
+	static int testID = 1;
+
+	public static void incrementTestID() {
+		RunTheServerUUT_TCPserverTest.testID += 1;
+	}
+	
+	@Before
+	public void before() throws IOException {
+		uut_TCPserver_1 = new UUT_TCPserver(port_1);
+		
+		System.out.println("\t\tTest Run "+RunTheServerUUT_TCPserverTest.testID+" Purpose:");
+		System.out.println(testPurpose[(RunTheServerUUT_TCPserverTest.testID-1)]);
+		System.out.println("\t\tTest Run "+RunTheServerUUT_TCPserverTest.testID+" Logic:");
+	}
+	 
+    /***********************************************************************************************************
+	 * Test Name: 
+	 * 		test_run_1
+	 * Description: 
+	 *		Verify that once the UUT_TCPserver class constructor is called, an empty instance of the TCP server class is created
+	 * Affected internal variables: 
+	 * 		TCPserver_INSTANCE
+	 * 		port
+	 * Affected external variables: 
+	 * 		TCPserver.serverSocket
+	 * 		TCPserver.serverThread
+	 *		TCPserver.serverRunning
+	 * Called internal functions:
+	 * 		UUT_TCPserver()
+	 * Exceptions thrown:
+	 * 		IOException
+	 ***********************************************************************************************************/
+	@Test
+	public void test_run_1() throws IOException {
+		
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE());
+		assertEquals(	null,		uut_TCPserver_1.getINSTANCE().getServerSocket());
+		assertEquals(	null,		uut_TCPserver_1.getINSTANCE().getServerThread());
+		assertFalse(uut_TCPserver_1.getINSTANCE().get_ServerRunning());
+	}
+	
+    /***********************************************************************************************************
+	 * Test Name: 
+	 * 		test_run_2
+	 * Description: 
+	 *		Verify that the RunTheServer function returns an updated and running instance of the server (in accordance with initServer() 
+	 *		method from the TCPserver class) that overwrites the previously created empty instance of the TCP server
+	 * Affected internal variables: 
+	 * 		TCPserver_INSTANCE
+	 * 		port
+	 * Affected external variables: 
+	 * 		TCPserver.serverSocket
+	 * 		TCPserver.serverThread
+	 * 		TCPserver.serverRunning
+	 * Called internal functions:
+	 * 		runTheServer()
+	 * 		closeTheServer()
+	 * 		UUT_TCPserver()
+	 * Exceptions thrown:
+	 * 		IOException
+	 ***********************************************************************************************************/
+	@Test
+	public void test_run_2() throws IOException {
+		
+		uut_TCPserver_1.setINSTANCE(UUT_TCPserver.runTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort()));
+		
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE());
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE().getServerSocket());
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE().getServerThread());
+		assertTrue(uut_TCPserver_1.getINSTANCE().get_ServerRunning());
+		
+		// close the server instance to prevent the Bind Exception from being thrown due to an attempt to bind a server socket twice to the same port
+		uut_TCPserver_1.setINSTANCE(UUT_TCPserver.closeTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort()));
+	}
+	
+	 /***********************************************************************************************************
+	 * Test Name: 
+	 * 		test_run_3
+	 * Description: 
+	 *		Verify that the instance of TCP server class (one of the attributes of the UUT_TCPserver class that is used 
+	 *		for calling the closeTheServer function) is being updated with up-to-date connection data each time 
+	 *		the setINSTANCE function is being called for this UUT_TCPserver class object.
+	 * Affected internal variables: 
+	 * 		TCPserver_INSTANCE
+	 * 		port
+	 * Affected external variables: 
+	 * 		TCPserver.serverSocket
+	 * 		TCPserver.serverThread
+	 * 		TCPserver.serverRunning
+	 * Called internal functions:
+	 * 		runTheServer()
+	 * 		closeTheServer()
+	 * 		UUT_TCPserver()
+	 * Exceptions thrown:
+	 * 		IOException
+	 ***********************************************************************************************************/
+	
+	@Test
+	public void test_run_3() throws IOException {
+		
+		uut_TCPserver_1.setINSTANCE(UUT_TCPserver.runTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort()));
+		
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE());
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE().getServerSocket());
+		assertNotEquals(null,		uut_TCPserver_1.getINSTANCE().getServerThread());
+		assertTrue(uut_TCPserver_1.getINSTANCE().get_ServerRunning());
+		
+		TCPserver tempTCPserver = uut_TCPserver_1.getINSTANCE();
+		ServerSocket tempServerSocket = uut_TCPserver_1.getINSTANCE().getServerSocket();
+		Thread tempServerThread = uut_TCPserver_1.getINSTANCE().getServerThread();
+
+		uut_TCPserver_1.setINSTANCE(UUT_TCPserver.closeTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort()));
+		assertFalse(uut_TCPserver_1.getINSTANCE().get_ServerRunning());
+		
+		uut_TCPserver_1.setINSTANCE(UUT_TCPserver.runTheServer(uut_TCPserver_1.getINSTANCE(), uut_TCPserver_1.getPort()));
+
+		assertNotEquals(tempTCPserver,		uut_TCPserver_1.getINSTANCE());
+		assertNotEquals(tempServerSocket,	uut_TCPserver_1.getINSTANCE().getServerSocket());
+		assertNotEquals(tempServerThread,	uut_TCPserver_1.getINSTANCE().getServerThread());
+		assertTrue(uut_TCPserver_1.getINSTANCE().get_ServerRunning());
+	}
+	
+	
+   @After
+    public void teardown() throws IOException, InterruptedException{
+	  
+	   System.out.println("\t\tTest Run "+RunTheServerUUT_TCPserverTest.testID+" teardown section:");
+	   	   
+	   // Time offset between consecutive test runs execution
+	   Thread.sleep(1000);
+
+	   incrementTestID();
+    }
+	   
+}

---JavaWorkspace_MT/UnitUnderTest/src/test/java/deliverables/StartTCPserverTest.java
=======================================================
lhs: 100644 | 8eb1c292b3a6423c889e67f5a824755df053e6bd
rhs: None
file deleted in rhs
---@@ -1,122 +0,0 @@
-package deliverables;
-
-import static org.junit.Assert.*;
-
-import java.io.IOException;
-import java.net.ServerSocket;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import tcpServer.TCPserver;
-
-public class StartTCPserverTest {
-
-	/***********************************************************************************************************
-	 * StartTCPserverTest - Class Attributes
-	 ***********************************************************************************************************/
-	int port_1 = 9876;
-	TCPserver temp_TCPserver = null;
-	
-	String[] testPurpose = { 	"Verify that once the getInstance() function for the TCPserver server class, the instance of the TCPserver class is being created with attributes set to their values",
-								"Verify that if the getInstance() function for the TCPserver server class is being called for the second time, the instance of the TCPserver class is being overwritten with TCPserver that is able to handle TCP communication",
-								"Verify that if the getInstance() function for the TCPserver server class is being called after closing the previous TCP communication mechanism, the instance of the TCPserver class is being overwritten with up-to-date TCPserver data"};
-	static int testID = 1;
-
-	public static void incrementTestID() {
-		StartTCPserverTest.testID += 1;
-	}
-	
-	@Before
-	public void before() throws IOException {
-		
-		temp_TCPserver = TCPserver.getInstance(port_1);
-		
-		System.out.println("\t\tTest Run "+StartTCPserverTest.testID+" Purpose:");
-		System.out.println(testPurpose[(StartTCPserverTest.testID-1)]);
-		System.out.println("\t\tTest Run "+StartTCPserverTest.testID+" Logic:");
-	}
-	 
-    /***********************************************************************************************************
-	 * Test Name: test_run_1
-	 * Description: Verify that once the getInstance() function for the TCPserver server class, the instance of the TCPserver class is being created with attributes set to their values
-	 * Affected external variables: TCPserver_instance, TCPserver.serverSocket, TCPserver.serverThread, TCPserver.serverRunning
-	 * Exceptions thrown: IOException
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_1() throws IOException{
-		
-		assertNotEquals(null,		temp_TCPserver);
-		assertEquals(	null,		TCPserver.getServerSocket());
-		assertEquals(	null,		TCPserver.getServerThread());
-		assertFalse(TCPserver.get_ServerRunning());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: test_run_2
-	 * Description: Verify that if the getInstance() function for the TCPserver server class is being called for the second time, 
-	 				the instance of the TCPserver class is being overwritten with TCPserver that is able to handle TCP communication
-	 * Affected external variables: TCPserver_instance, TCPserver.serverSocket, TCPserver.serverThread, TCPserver.serverRunning
-	 * Exceptions thrown: IOException
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_2() throws IOException {
-		
-		temp_TCPserver = TCPserver.getInstance(port_1);
-		
-		assertNotEquals(null,		temp_TCPserver);
-		assertNotEquals(null,		TCPserver.getServerSocket());
-		assertNotEquals(null,		TCPserver.getServerThread());
-		assertTrue(TCPserver.get_ServerRunning());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: test_run_3
-	 * Description: Verify that if the getInstance() function for the TCPserver server class is being called after closing the previous TCP communication mechanism,
-	 				the instance of the TCPserver class is being overwritten with up-to-date TCPserver data
-	 * Affected external variables: TCPserver_instance, TCPserver.serverSocket, TCPserver.serverThread, TCPserver.serverRunning
-	 * Exceptions thrown: IOException
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_3() throws IOException {
-		
-		temp_TCPserver = TCPserver.getInstance(port_1);
-		
-		assertNotEquals(null,		temp_TCPserver);
-		assertNotEquals(null,		TCPserver.getServerSocket());
-		assertNotEquals(null,		TCPserver.getServerThread());
-		assertTrue(TCPserver.get_ServerRunning());
-		
-		TCPserver temp_TCPserver_prev = TCPserver.getInstance(port_1);
-		ServerSocket temp_ServerSocket_prev = TCPserver.getServerSocket();
-		Thread temp_ServerThread_prev = TCPserver.getServerThread();
-		
-		// close the server instance to prevent the Bind Exception from being thrown due to an attempt to bind a server socket twice to the same port
-		TCPserver.getInstance(port_1).closeServer(TCPserver.getInstance(port_1), port_1);
-		
-		temp_TCPserver = TCPserver.getInstance(port_1);
-
-		temp_TCPserver = TCPserver.getInstance(port_1);
-		
-		assertNotEquals(temp_TCPserver_prev,		temp_TCPserver);
-		assertNotEquals(temp_ServerSocket_prev,		TCPserver.getServerSocket());
-		assertNotEquals(temp_ServerThread_prev,		TCPserver.getServerThread());
-		assertTrue(TCPserver.get_ServerRunning());
-	}
-	
-	
-   @After
-    public void teardown() throws IOException, InterruptedException{
-	  
-	   System.out.println("\t\tTest Run "+StartTCPserverTest.testID+" teardown section:");
-	   	  
-		// close the server instance to prevent the Bind Exception from being thrown due to an attempt to bind a server socket twice to the same port
-		TCPserver.getInstance(port_1).closeServer(TCPserver.getInstance(port_1), port_1);
-		
-	   // Time offset between consecutive test runs execution
-	   Thread.sleep(1000);
-
-	   incrementTestID();
-    }
-	   
-}

---JavaWorkspace_MT/UnitUnderTest/src/test/java/tcpServer/CloseServerTCPserverTest.java
=======================================================
lhs: 100644 | b2a5412e2eb7916bd4c41038b396b7eb3a6f26b5
rhs: 100644 | b4cc85556e810bef46741000b2db6bd84f76c639
---@@ -6,34 +6,32 @@ import java.io.IOException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
-import tcpServer.TCPserver;
-import watchdog.Global_1h_Watchdog;
 
 public class CloseServerTCPserverTest {
 
-	/***********************************************************************************************************
-	 * CloseServerTCPserverTest - Class Attributes
-	 ***********************************************************************************************************/
 	int port_1 = 9876;
-	TCPserver tempTCPserver = null;
+	TCPserver tcpserver_1 = null;
+	int port_2 = 9877;
+	TCPserver tcpserver_2 = null;
 
-	String[] testPurpose = { "Verify that that once the previously created TCPserver instance is being closed, this instance is being overwritten with up-to-date attributes that indicate TCP communication is not active",
-							 "Verify that that once the previously created TCPserver instance is being closed intentionally, 1h_Watchdog TimeLeftBeforeExpiration is being set to its initial limit (_1h_WatchdogExpiration)",
-							 "Verify that there is the IllegalArgumentException returned if there was an attempt to close the TCPsever instance that has been already closed"}; 
+	
+	String[] testPurpose = { 	"Verify that once the previously initialized server is closed, the new server instance can be initialized at the same port as previous",
+								"Verify that if a server instance at some port was closed, the other servers at different ports are not being closed",
+			 					"Verify that there is NO IllegalArgumentException returned if there was an attempt to close twice the server that has been initiated",
+			 					"Verify that there is the IllegalArgumentException returned if there was an attempt to close the server that has not been initialized"};
 	static int testID = 1;
 	
 	public static void incrementTestID() {
 		CloseServerTCPserverTest.testID += 1;
 	}
 	
+	
 	@Before
 	public void before() throws IOException {
+		tcpserver_1 = new TCPserver();
 		
-		if (CloseServerTCPserverTest.testID < 3) {
-			TCPserver.getInstance(port_1);
-		}
-		if (CloseServerTCPserverTest.testID == 3) {
-			tempTCPserver = TCPserver.getInstance(port_1);
+		if(CloseServerTCPserverTest.testID == 2) {
+			tcpserver_2 = new TCPserver();
 		}
 		
 		System.out.println("\t\tTest Run "+CloseServerTCPserverTest.testID+" Purpose:");
@@ -41,66 +39,71 @@ public class CloseServerTCPserverTest {
 		System.out.println("\t\tTest Run "+CloseServerTCPserverTest.testID+" Logic:");
 	}
 	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_1
-	 * Description:				Verify that that once the previously created TCPserver instance is being closed, 
-					 			this instance is being overwritten with up-to-date attributes that indicate TCP communication is not active
-	 * Internal variables TBV: 	TCPserver_instance, TCPserver.serverSocket, TCPserver.serverThread, TCPserver.serverRunning
-	 * Exceptions thrown:		IOException
-	 ***********************************************************************************************************/
+
 	@Test
 	public void test_run_1() throws IOException {
 		
-		TCPserver.getInstance(port_1);
+		tcpserver_1 = tcpserver_1.initServer(port_1);
+		assertTrue(tcpserver_1.isServerRunning());
+		assertFalse(tcpserver_1.getServerSocket().isClosed());
 
-		TCPserver.getInstance(port_1).closeServer(TCPserver.getInstance(port_1), port_1);
+		tcpserver_1.closeServer(tcpserver_1, port_1);
+		assertFalse(tcpserver_1.isServerRunning());
+		assertTrue(tcpserver_1.getServerSocket().isClosed());
 		
-		assertTrue(TCPserver.getServerThread().isInterrupted());
-		assertTrue(TCPserver.getServerSocket().isClosed());
-		assertFalse(TCPserver.get_ServerRunning());
+		tcpserver_1 = tcpserver_1.initServer(port_1);
+		assertTrue(tcpserver_1.isServerRunning());
+		assertFalse(tcpserver_1.getServerSocket().isClosed());
 	}
 	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_2
-	 * Description: 			Verify that that once the previously created TCPserver instance is being closed intentionally, 
-	 							1h_Watchdog TimeLeftBeforeExpiration is being set to its initial limit (_1h_WatchdogExpiration)
-	 * External variables TBV: 	Global_1h_Watchdog.millisecondsLeftUntilExpiration
-	 * Exceptions thrown: 		IOException
-	 ***********************************************************************************************************/
 	@Test
 	public void test_run_2() throws IOException {
 
-		TCPserver.getInstance(port_1);
-		double prev = Global_1h_Watchdog.getInstance().getTimeLeftBeforeExpiration();
-		double temp_1h_WatchdogExpiration =  Global_1h_Watchdog.getInstance().getExpiration() * TCPserver.getWatchdogs_scale_factor() ;
+		tcpserver_1 = tcpserver_1.initServer(port_1);
+		assertTrue(tcpserver_1.isServerRunning());
+		assertFalse(tcpserver_1.getServerSocket().isClosed());
+		
+		tcpserver_2 = tcpserver_2.initServer(port_2);
+		assertTrue(tcpserver_2.isServerRunning());
+		assertFalse(tcpserver_2.getServerSocket().isClosed());
 
-		TCPserver.getInstance(port_1).closeServer(TCPserver.getInstance(port_1), port_1);
-		double curr_1 = Global_1h_Watchdog.getInstance().getTimeLeftBeforeExpiration(); 
+		tcpserver_1.closeServer(tcpserver_1, port_1);
+		assertFalse(tcpserver_1.isServerRunning());
+		assertTrue(tcpserver_1.getServerSocket().isClosed());
+		assertTrue(tcpserver_2.isServerRunning());
+		assertFalse(tcpserver_2.getServerSocket().isClosed());
 			
-		assertEquals( temp_1h_WatchdogExpiration,	 curr_1, 0.001);
-		assertTrue("Current 1h_Watchdog TimeLeftBeforeExpiration (" + curr_1 + ") should be greater than previous (" + prev + ")", curr_1 > prev);
 	}
 	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_3
-	 * Description: 			Verify that there is the IllegalArgumentException returned if there was an attempt to close the TCPsever instance that has been already closed
-	 * Exceptions thrown TBV:	IllegalArgumentException
-	 * Exceptions thrown:		IOException
-	 ***********************************************************************************************************/
-	@Test(expected = IllegalArgumentException.class)
+	@Test
 	public void test_run_3() throws IOException {
 
-		tempTCPserver = TCPserver.getInstance(port_1);
+		tcpserver_1 = tcpserver_1.initServer(port_1);
+		assertTrue(tcpserver_1.isServerRunning());
+		assertFalse(tcpserver_1.getServerSocket().isClosed());
 
-		tempTCPserver.closeServer(tempTCPserver, port_1);
+		tcpserver_1.closeServer(tcpserver_1, port_1);
+		assertFalse(tcpserver_1.isServerRunning());
+		assertTrue(tcpserver_1.getServerSocket().isClosed());
 		
-		tempTCPserver.closeServer(tempTCPserver, port_1);
+		tcpserver_1.closeServer(tcpserver_1, port_1);
+		assertFalse(tcpserver_1.isServerRunning());
+		assertTrue(tcpserver_1.getServerSocket().isClosed());
+			
+	}
+	
+	@Test(expected = IllegalArgumentException.class)
+	public void test_run_4() throws IOException {
+		
+		
+		tcpserver_1.closeServer(tcpserver_1, port_1);
 		
 		// To prove that exception's stack trace reported by JUnit caught the IllegalArgumentException
 		assertTrue(false);
+			
 	}
 	
-	@After
+   @After
     public void teardown() throws IOException, InterruptedException{
 	  
 	   System.out.println("\t\tTest Run "+CloseServerTCPserverTest.testID+" teardown section:");
@@ -108,6 +111,21 @@ public class CloseServerTCPserverTest {
 	   // Time offset between consecutive test runs execution
 	   Thread.sleep(1000);
 	   
+	   if(tcpserver_1 != null) {
+		   if(tcpserver_1.isServerRunning()){
+			   tcpserver_1.closeServer(tcpserver_1, port_1);
+		   }
+		   
+	   }
+	   if(tcpserver_2 != null){
+		   if(tcpserver_2.isServerRunning()){
+			   tcpserver_2.closeServer(tcpserver_2, port_2);
+		   
+		   }
+	   }
+	   
 	   incrementTestID();
     }
+	
+	
 }

---JavaWorkspace_MT/UnitUnderTest/src/test/java/tcpServer/StartServerTCPserverTest.java
=======================================================
lhs: 100644 | 93188677b75eaca7c206abb752f4e2911b7544ee
rhs: 100644 | 57fedf3bdd4188de550f626dd4267621c47830e7
---@@ -8,6 +8,8 @@ import java.net.Socket;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+
+import messages.ClientMessage_BootUp;
 import tcpClient.ClientManager;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;;
@@ -59,12 +61,12 @@ public class StartServerTCPserverTest {
 		
 		serverSocket_1.setReuseAddress(true);
 	    serverSocket_1.bind(new java.net.InetSocketAddress(port_1));
-	    TCPserver.set_ServerRunning(true);
+	    tcpserver_1.ServerRunning(true);
 
-		assertEquals(null, 		TCPserver.getServerThread());
+		assertEquals(null, 		tcpserver_1.getServerThread());
 		
 		tcpserver_1.startServer(serverSocket_1);
-		assertNotEquals(null, 	TCPserver.getServerThread());
+		assertNotEquals(null, 	tcpserver_1.getServerThread());
 		
 	}
 	
@@ -73,13 +75,13 @@ public class StartServerTCPserverTest {
 		
 		serverSocket_1.setReuseAddress(true);
 		serverSocket_1.bind(new java.net.InetSocketAddress(port_1));    
-	    TCPserver.set_ServerRunning(true);
+	    tcpserver_1.ServerRunning(true);
 		tcpserver_1.startServer(serverSocket_1);
-		Thread testThread1 = TCPserver.getServerThread();
+		Thread testThread1 = tcpserver_1.getServerThread();
 		serverSocket_2.bind(new java.net.InetSocketAddress(port_2));
-	    TCPserver.set_ServerRunning(true);
+	    tcpserver_2.ServerRunning(true);
 		tcpserver_2.startServer(serverSocket_2);
-		Thread testThread2 = TCPserver.getServerThread();
+		Thread testThread2 = tcpserver_2.getServerThread();
 
 		assertNotEquals(testThread2, 	testThread1);
 	}
@@ -89,15 +91,15 @@ public class StartServerTCPserverTest {
 		
 		serverSocket_1.setReuseAddress(true);
 		serverSocket_1.bind(new java.net.InetSocketAddress(port_1));    
-	    TCPserver.set_ServerRunning(true);
+	    tcpserver_1.ServerRunning(true);
 		tcpserver_1.startServer(serverSocket_1);
 		
-		assertEquals(Thread.State.RUNNABLE,		TCPserver.getServerThread().getState());
+		assertEquals(Thread.State.RUNNABLE,		tcpserver_1.getServerThread().getState());
 		
 		serverSocket_1.close();
 		Thread.sleep(100);
 		
-		assertEquals(Thread.State.TERMINATED,	TCPserver.getServerThread().getState());
+		assertEquals(Thread.State.TERMINATED,	tcpserver_1.getServerThread().getState());
 	}
 	
 	@Test
@@ -105,7 +107,7 @@ public class StartServerTCPserverTest {
 		
 		serverSocket_1.setReuseAddress(true);
 		serverSocket_1.bind(new java.net.InetSocketAddress(port_1));
-		TCPserver.set_ServerRunning(true);
+		tcpserver_1.ServerRunning(true);
 		tcpserver_1.startServer(serverSocket_1);
 		clientSocket = new Socket(serverHostName, port_1);
 		
@@ -118,7 +120,7 @@ public class StartServerTCPserverTest {
 		
 		serverSocket_1.setReuseAddress(true);
 		serverSocket_1.bind(new java.net.InetSocketAddress(port_1));
-		TCPserver.set_ServerRunning(true);
+		tcpserver_1.ServerRunning(true);
 		//tcpserver_1.ComputeEngineRunning(false);
 		tcpserver_1.startServer(serverSocket_1);			
 		clientSocket = new Socket(serverHostName, port_1);
@@ -153,7 +155,7 @@ public class StartServerTCPserverTest {
 		
 		serverSocket_1.setReuseAddress(true);
 		serverSocket_1.bind(new java.net.InetSocketAddress(port_1));
-		TCPserver.set_ServerRunning(true);
+		tcpserver_1.ServerRunning(true);
 		//tcpserver_1.ComputeEngineRunning(false);
 		tcpserver_1.startServer(serverSocket_1);			
 		

---JavaWorkspace_MT/UnitUnderTest/src/test/java/tcpServer/TCPserverTest.java
=======================================================
lhs: 100644 | 624035ce6a849b90255e786afeb195d05f6d1eef
rhs: None
file deleted in rhs
---@@ -1,161 +0,0 @@
-package tcpServer;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-import java.io.File;
-import java.io.IOException;
-import java.net.SocketException;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import watchdog.Global_1h_Watchdog;
-import watchdog.Global_24h_Watchdog;
-
-public class TCPserverTest {
-	
-	TCPserver tcpserver_1 = null;
-	int port_1 = 9876;
-	
-	String[] testPurpose = { "Verify that once the overloaded constructor of the TCPserver class is called, the TCPserver class instance is updated with new server socket that is bound to the port and has ReuseAddress set to TRUE",
-							 "Verify that once the overloaded constructor of the TCPserver class is called, the TCPserver class instance is updated with the serverRunning flag set to TRUE",
-							 "Verify that once the overloaded constructor of the TCPserver class is called, the 1h_Watchdog and 24h_Watchdog instances are enabled along with their threads",
-							 "Verify that once the overloaded constructor of the TCPserver class is called, the instance of the ComputeEngine_Processing class for processing of the serialized files is created and the deleteAllFilesFromDirectiory is called",
-							 "Verify that once the default constructor of the TCPserver class is being called, the 1h_Watchdog and 24h_Watchdog instances are being created with its local attribute server_watchgod_scale_factor that is equal to TCPserver.watchdogs_scale_factor",
-							 "Verify that the default constructor of the TCPserver class can be called multiple times with no exception being thrown. Verify that after each constructor call, the TCPserver instance is being updated with up-to-date attributes, e.g. watchdogs_scale_factors"};
-	static int testID = 1;
-	
-	public static void incrementTestID() {
-		TCPserverTest.testID += 1;
-	}
-	
-	@Before
-	public void before() throws IOException {
-		
-		tcpserver_1 = new TCPserver(port_1);
-		
-		System.out.println("\t\tTest Run "+TCPserverTest.testID+" Purpose:");
-		System.out.println(testPurpose[(TCPserverTest.testID-1)]);
-		System.out.println("\t\tTest Run "+TCPserverTest.testID+" Logic:");
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_1
-	 * Description: 			Verify that once the overloaded constructor of the TCPserver class is called, 
-	 * 							the TCPserver class instance is being updated with new server socket that is bound to the port and has ReuseAddress set to TRUE
-	 * Internal variables TBV: 	serverSocket
-      * Exceptions thrown:		SocketException 
-	 ***********************************************************************************************************/
-	@SuppressWarnings("static-access")
-	@Test
-	public void test_run_1() throws SocketException {
-
-		assertNotEquals(null, tcpserver_1.getServerSocket());
-		assertTrue(tcpserver_1.getServerSocket().isBound());
-		assertTrue(tcpserver_1.getServerSocket().getReuseAddress());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_2
-	 * Description: 			Verify that once the overloaded constructor of the TCPserver class is called, 
-	 * 							the TCPserver class instance is being updated with the serverRunning flag set to TRUE
-	 * Internal variables TBV: 	serverRunning
-	 ***********************************************************************************************************/
-	@SuppressWarnings("static-access")
-	@Test
-	public void test_run_2() {
-
-		assertTrue(tcpserver_1.get_ServerRunning());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_3
-	 * Description: 			Verify that once the overloaded constructor of the TCPserver class is being called, the 1h_Watchdog and 24h_Watchdog instances are enabled along with their threads
-	 * External variables TBV: 	Global_1h_Watchdog.isPaused, Global_24h_Watchdog.isPaused, Global_1h_Watchdog._1h_WatchdogThread, Global_24h_Watchdog._1h_WatchdogThread
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_3() {
-
-		assertTrue(Global_1h_Watchdog.getInstance().getEnabled());
-		assertTrue(Global_1h_Watchdog.getInstance().isAlive());
-		
-		assertTrue(Global_24h_Watchdog.getInstance().getEnabled());
-		assertTrue(Global_24h_Watchdog.getInstance().isAlive());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_4
-	 * Description: 			Verify that once the overloaded constructor of the TCPserver class is called, 
-	 * 							the instance of the ComputeEngine_Processing class for processing serialized files is created and the deleteAllFilesFromDirectiory is called
-	 * Internal variables TBV: 	processing_engine, Sensors_PATH
-	 ***********************************************************************************************************/
-	@SuppressWarnings("static-access")
-	@Test
-	public void test_run_4() {
-
-		assertNotEquals(null, tcpserver_1.getProcessing_engine());
-		
-		String new_path = null;
-		File file_path = null;
-		File files_to_be_deleted_path = null;
-		file_path = new java.io.File(tcpserver_1.Sensors_PATH);
-		String[]entries_1 = file_path.list();
-		for (int i = 0; i< entries_1.length; i++) {
-			new_path = tcpserver_1.Sensors_PATH + "\\" + entries_1[i];
-			file_path = new java.io.File(new_path);
-			String[]entries_2 = file_path.list();
-			for (int j = 0; j< entries_2.length; j++) {
-				new_path = tcpserver_1.Sensors_PATH  + "\\" + entries_1[i] + "\\" + entries_2[j];
-				files_to_be_deleted_path = new java.io.File(new_path);
-				// the sensor_Infos files are created once the overloaded constructor of the TCPserver class is called, 
-				// hence there will be new sensor_Infos files created after deleting all files from previous TCP communication session, 
-				// hence if a folder name equals "sensor_Infos", the assertEquals condition is not executed for this for loop iteration
-				if(entries_2[j].equals("sensor_Infos")) continue;
-				// if an array returned by listFiles() is empty, an evidence that all files have been deleted is given
-				assertEquals(0, files_to_be_deleted_path.listFiles());
-			}
-		}
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_5
-	 * Description: 			Verify that the default constructor of the TCPserver class can be called multiple times with no exception being thrown. Verify that after each constructor call, the TCPserver instance is being updated with up-to-date attributes, e.g. watchdogs_scale_factors
-	 * Internal variables TBV: 	watchdogs_scale_factor
-	 * External variables TBV: 	Global_1h_Watchdog.server_watchgod_scale_factor, Global_24h_Watchdog.server_watchgod_scale_factor
-	 * Exceptions thrown:		IOException
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_5() throws IOException {
-
-		tcpserver_1 = new TCPserver();
-		TCPserver temp_TCPserver_1 = tcpserver_1;
-		
-		assertEquals(Global_1h_Watchdog.getServer_watchgod_scale_factor(), TCPserver.getWatchdogs_scale_factor(), 0.0001);
-		assertEquals(Global_24h_Watchdog.getServer_watchgod_scale_factor(), TCPserver.getWatchdogs_scale_factor(), 0.0001);
-		
-		assertNotEquals(null, tcpserver_1);
-		
-		tcpserver_1 = new TCPserver();
-		double temp_watchdogs_scale_factor = 0.01;
-		TCPserver.setWatchdogs_scale_factor(temp_watchdogs_scale_factor);
-		TCPserver temp_TCPserver_2 = tcpserver_1;
-		
-		assertNotEquals(temp_TCPserver_1, temp_TCPserver_2);
-		assertEquals(Global_1h_Watchdog.getServer_watchgod_scale_factor(), temp_watchdogs_scale_factor, 0.0001);
-		assertEquals(Global_24h_Watchdog.getServer_watchgod_scale_factor(), temp_watchdogs_scale_factor, 0.0001);	
-	}
-	
-   @After
-    public void teardown() throws IOException, InterruptedException{
-	   
-	   System.out.println("\t\tTest Run "+TCPserverTest.testID+" teardown section:");
-	   
-	   tcpserver_1.closeServer(tcpserver_1, port_1);
-	   // Time offset between consecutive test runs execution
-	   Thread.sleep(1000);
-	   
-	   System.out.println("");
-	   incrementTestID();
-    }
-
-}

---JavaWorkspace_MT/UnitUnderTest/src/test/java/tcpServer/publicTCPserverTest.java
=======================================================
lhs: 100644 | a4f691b7a2b809a0af4f95ccd2794dac199ebabd
rhs: None
file deleted in rhs
---@@ -1,129 +0,0 @@
-package tcpServer;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import java.io.IOException;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import watchdog.Global_1h_Watchdog;
-import watchdog.Global_24h_Watchdog;
-
-public class publicTCPserverTest {
-	
-	TCPserver tcpserver_1 = null;
-	
-	String[] testPurpose = { "Verify that once the default constructor of the TCPserver class is being called, the TCPserver class instance is created with attributes set to their initial values",
-							 "Verify that once the default constructor of the TCPserver class is being called, the array lists that temporarily store sensors and measurements are created",
-							 "Verify that once the default constructor of the TCPserver class is being called, sensor_coordinates_array has number of elements equals to number of elements in_Watchog_timestamp_tables",
-							 "Verify that once the default constructor of the TCPserver class is being called, the 1h_Watchdog and 24h_Watchdog instances are being created with its local attribute server_watchgod_scale_factor that is equal to TCPserver.watchdogs_scale_factor",
-							 "Verify that the default constructor of the TCPserver class can be called multiple times with no exception being thrown. Verify that after each constructor call, the TCPserver instance is being updated with up-to-date attributes, e.g. watchdogs_scale_factors"};
-	static int testID = 1;
-	
-	public static void incrementTestID() {
-		publicTCPserverTest.testID += 1;
-	}
-	
-	@Before
-	public void before() throws IOException {
-		
-		tcpserver_1 = new TCPserver();
-		
-		System.out.println("\t\tTest Run "+publicTCPserverTest.testID+" Purpose:");
-		System.out.println(testPurpose[(publicTCPserverTest.testID-1)]);
-		System.out.println("\t\tTest Run "+publicTCPserverTest.testID+" Logic:");
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_1
-	 * Description: 			Verify that once the default constructor of the TCPserver class is being called, the TCPserver class instance is created with attributes set to their initial values
-	 * Internal variables TBV: 	serverSocket, serverThread, serverRunning
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_1() {
-
-		assertFalse(TCPserver.get_ServerRunning());
-		assertEquals(null, TCPserver.getServerSocket());
-		assertEquals(null, TCPserver.getServerThread());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_2
-	 * Description: 			Verify that once the default constructor of the TCPserver class is being called, the array lists that temporarily store sensors and measurements are created
-	 * Internal variables TBV: 	Server_Sensors_LIST, MeasurementHistory_LIST, MeasurementData_LIST
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_2() {
-
-		assertEquals(0, TCPserver.Server_Sensors_LIST.size());
-		assertEquals(0, TCPserver.MeasurementHistory_LIST.size());
-		assertEquals(0, TCPserver.MeasurementData_LIST.size());
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_3
-	 * Description: 			Verify that once the default constructor of the TCPserver class is being called, sensor_coordinates_array has number of elements equals to number of elements in_Watchog_timestamp_tables
-	 * Internal variables TBV: 	_1hWatchog_timestamp_table, _24hWatchog_timestamp_table, sensor_coordinates_array
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_3() {
-
-		assertEquals(tcpserver_1.sensor_coordinates_array.length, TCPserver.get_1hWatchog_timestamp_table().get().length);
-		assertEquals(tcpserver_1.sensor_coordinates_array.length, TCPserver.get_24hWatchog_timestamp_table().get().length);
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_4
-	 * Description: 			Verify that once the default constructor of the TCPserver class is being called, the 1h_Watchdog and 24h_Watchdog instances are being created with its local attribute server_watchgod_scale_factor that is equal to TCPserver.watchdogs_scale_factor
-	 * Internal variables TBV: 	watchdogs_scale_factor
-	 * External variables TBV: 	Global_1h_Watchdog.server_watchgod_scale_factor, Global_24h_Watchdog.server_watchgod_scale_factor
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_4() {
-
-		assertEquals(Global_1h_Watchdog.getServer_watchgod_scale_factor(), TCPserver.getWatchdogs_scale_factor(), 0.0001);
-		assertEquals(Global_24h_Watchdog.getServer_watchgod_scale_factor(), TCPserver.getWatchdogs_scale_factor(), 0.0001);
-	}
-	
-    /***********************************************************************************************************
-	 * Test Name: 				test_run_5
-	 * Description: 			Verify that the default constructor of the TCPserver class can be called multiple times with no exception being thrown. Verify that after each constructor call, the TCPserver instance is being updated with up-to-date attributes, e.g. watchdogs_scale_factors
-	 * Internal variables TBV: 	watchdogs_scale_factor
-	 * External variables TBV: 	Global_1h_Watchdog.server_watchgod_scale_factor, Global_24h_Watchdog.server_watchgod_scale_factor
-	 * Exceptions thrown:		IOException
-	 ***********************************************************************************************************/
-	@Test
-	public void test_run_5() throws IOException {
-
-		tcpserver_1 = new TCPserver();
-		TCPserver temp_TCPserver_1 = tcpserver_1;
-		
-		assertEquals(Global_1h_Watchdog.getServer_watchgod_scale_factor(), TCPserver.getWatchdogs_scale_factor(), 0.0001);
-		assertEquals(Global_24h_Watchdog.getServer_watchgod_scale_factor(), TCPserver.getWatchdogs_scale_factor(), 0.0001);
-		
-		assertNotEquals(null, tcpserver_1);
-		
-		tcpserver_1 = new TCPserver();
-		double temp_watchdogs_scale_factor = 0.01;
-		TCPserver.setWatchdogs_scale_factor(temp_watchdogs_scale_factor);
-		TCPserver temp_TCPserver_2 = tcpserver_1;
-		
-		assertNotEquals(temp_TCPserver_1, temp_TCPserver_2);
-		assertEquals(Global_1h_Watchdog.getServer_watchgod_scale_factor(), temp_watchdogs_scale_factor, 0.0001);
-		assertEquals(Global_24h_Watchdog.getServer_watchgod_scale_factor(), temp_watchdogs_scale_factor, 0.0001);	
-	}
-	
-   @After
-    public void teardown() throws IOException, InterruptedException{
-	   
-	   System.out.println("\t\tTest Run "+publicTCPserverTest.testID+" teardown section:");
-	   
-	   // Time offset between consecutive test runs execution
-	   Thread.sleep(1000);
-	   
-	   System.out.println("");
-	   incrementTestID();
-    }
-
-}

---